<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gestures Particles - Centered Heart</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; touch-action: none; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 20px; z-index: 10; pointer-events: none; text-align: center;
        }
        #instructions {
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.4);
            font-size: 13px; pointer-events: none; width: 90%;
        }
        video { display: none; }
        canvas { display: block; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

<div id="loading">Initializing System...</div>
<div id="instructions">üñê PALM: SATURN | ‚úä FIST: SPHERE | ‚úåÔ∏è PEACE: CENTERED HEART | ü§ü ILY: TEXT</div>

<video id="video-input" playsinline></video>

<script>
/* ================= POLYFILL FROM IMAGE ================= */
(function() {
    let lastTime = 0;
    const vendors = ['ms', 'moz', 'webkit', 'o'];
    for(let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback) {
            let currTime = new Date().getTime();
            let timeToCall = Math.max(0, 16 - (currTime - lastTime));
            let id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) { clearTimeout(id); };
}());

/* ================= CONFIG ================= */
const CONFIG = {
    particleCount: 25000,
    returnSpeed: 0.12, 
    driftSpeed: 0.05 
};

let scene, camera, renderer, particles, targetPositions, currentPositions, offsets;
let handX = 0, handY = 0, smoothHandX = 0, smoothHandY = 0, handScale = 1.0;
let textCoordinates = []; 
let currentShape = 'Chaos';
let time = 0, hue = 0;
let handActive = false;

function generateTextPoints() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const w = 400; const h = 150;
    canvas.width = w; canvas.height = h;
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.font = 'bold 50px Arial'; 
    ctx.fillStyle = 'white';
    ctx.fillText("I Love You", w/2, h/2);
    const data = ctx.getImageData(0, 0, w, h).data;
    const coords = [];
    for(let y = 0; y < h; y += 2) {
        for(let x = 0; x < w; x += 2) {
            if (data[(y * w + x) * 4] > 128) {
                coords.push({x: (x - w/2) * 0.15, y: -(y - h/2) * 0.15});
            }
        }
    }
    return coords;
}

function init() {
    textCoordinates = generateTextPoints();
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 40;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const geo = new THREE.BufferGeometry();
    currentPositions = new Float32Array(CONFIG.particleCount * 3);
    targetPositions = new Float32Array(CONFIG.particleCount * 3);
    offsets = new Float32Array(CONFIG.particleCount); 

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        currentPositions[i3] = (Math.random() - 0.5) * 100;
        currentPositions[i3+1] = (Math.random() - 0.5) * 100;
        currentPositions[i3+2] = (Math.random() - 0.5) * 100;
        offsets[i] = Math.random() * 100;
    }

    geo.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
    const mat = new THREE.PointsMaterial({ size: 0.12, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    particles = new THREE.Points(geo, mat);
    scene.add(particles);

    setShape('Chaos');
    animate();
}

function setShape(type) {
    if (currentShape === type) return;
    currentShape = type;

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        let x, y, z;

        if (type === 'Chaos') {
            x = (Math.random() - 0.5) * 100; y = (Math.random() - 0.5) * 100; z = (Math.random() - 0.5) * 100;
        } else if (type === 'Saturn') {
            if (Math.random() > 0.4) {
                const a = Math.random() * Math.PI * 2; const r = 18 + Math.random() * 6;
                x = Math.cos(a) * r; y = (Math.random() - 0.5) * 2; z = Math.sin(a) * r;
            } else {
                const r = 9; const t = Math.random() * Math.PI * 2; const p = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(p) * Math.cos(t); y = r * Math.sin(p) * Math.sin(t); z = r * Math.cos(p);
            }
        } else if (type === 'Sphere') {
            const r = 14; const phi = Math.acos(1 - 2 * Math.random()); const theta = Math.random() * Math.PI * 2;
            x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
        } else if (type === 'Heart') {
            const t = Math.random() * Math.PI * 2;
            // CENTERED HEART FORMULA
            x = 16 * Math.pow(Math.sin(t), 3) * 0.7; 
            y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.7; 
            z = (Math.random() - 0.5) * 2;
        } else if (type === 'ILU') {
            const coord = textCoordinates[i % textCoordinates.length];
            x = coord ? coord.x : 0; y = coord ? coord.y : 0; z = 0;
        }
        targetPositions[i3] = x;
        targetPositions[i3+1] = y;
        targetPositions[i3+2] = z;
    }
}

const video = document.getElementById('video-input');
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

hands.onResults((res) => {
    document.getElementById('loading').style.display = 'none';
    if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
        handActive = true;
        const lm = res.multiHandLandmarks[0];
        handX = (0.5 - lm[9].x) * 70; 
        handY = (0.5 - lm[9].y) * -50;
        const dx = lm[0].x - lm[9].x; const dy = lm[0].y - lm[9].y;
        handScale = THREE.MathUtils.mapLinear(Math.sqrt(dx*dx + dy*dy), 0.1, 0.4, 0.6, 2.5);

        const isExt = (t, p) => lm[t].y < lm[p].y;
        const index = isExt(8, 6), mid = isExt(12, 10), ring = isExt(16, 14), pinky = isExt(20, 18);
        const thumb = Math.abs(lm[4].x - lm[17].x) > 0.1;

        if (index && pinky && thumb && !mid && !ring) setShape('ILU');
        else if (index && mid && !ring && !pinky) setShape('Heart');
        else if (!index && !mid && !ring && !pinky) setShape('Sphere');
        else if (index && mid && ring && pinky) setShape('Saturn');
    } else {
        handActive = false;
        setShape('Chaos');
    }
});

new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 640, height: 480 }).start();

function animate() {
    window.requestAnimationFrame(animate); // Uses the polyfill
    time += 0.01;
    hue = (hue + 0.5) % 360;
    particles.material.color.setHSL(hue / 360, 0.8, 0.6);

    smoothHandX += (handX - smoothHandX) * 0.1;
    smoothHandY += (handY - smoothHandY) * 0.1;

    const pos = particles.geometry.attributes.position.array;
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        let tx = targetPositions[i3];
        let ty = targetPositions[i3+1];
        let tz = targetPositions[i3+2];

        // Apply hand movement ONLY to non-centered shapes (Saturn/Sphere)
        if (handActive && currentShape !== 'Chaos') {
            tx *= handScale; ty *= handScale; tz *= handScale;
            // Only follow hand position for Sphere and Saturn
            if (currentShape !== 'ILU' && currentShape !== 'Heart') {
                tx += smoothHandX; ty += smoothHandY;
            }
        }

        if (currentShape === 'Chaos') {
            const off = offsets[i];
            tx += Math.sin(time * 0.4 + off) * 25;
            ty += Math.cos(time * 0.2 + off) * 25;
            tz += Math.sin(time * 0.6 + off) * 15;
        }

        pos[i3]   += (tx - pos[i3]) * CONFIG.returnSpeed;
        pos[i3+1] += (ty - pos[i3+1]) * CONFIG.returnSpeed;
        pos[i3+2] += (tz - pos[i3+2]) * CONFIG.returnSpeed;
    }
    particles.geometry.attributes.position.needsUpdate = true;
    
    // Disable rotation for Heart and Text to keep them stable in center
    if (currentShape === 'Saturn' || currentShape === 'Sphere') {
        particles.rotation.y += 0.01;
    } else {
        particles.rotation.y *= 0.9;
    }
    
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>